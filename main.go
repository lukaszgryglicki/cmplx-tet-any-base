package main

import (
	"fmt"
	"image"
	"image/color"
	"image/png"
	"math"
	"math/cmplx"
	"os"
	"strconv"
)

const (
	L  = complex128(0.3181315052047641353 + 1.337235701430689409i)
	Zo = complex128(0.31813150520476413 + 1.3372357014306895i)
	Zc = complex128(0.31813150520476413 - 1.3372357014306895i)
)

var (
	gDebug = false
	DEA    = [...]complex128{
		1.4192252155045112363,
		-0.05213258059503801667,
		0.00693219127232187586,
		-0.00015617045803377859,
		-0.00100912103192385785,
		0.00082172671942507903,
		-0.00035776641706493177,
		-0.00000931803078422933,
		0.00016678111348857047,
		-0.00014181446429806932,
		0.00003186488716454018,
		0.00006022937595596333,
		-0.00007769822429012910,
		0.00002881816919640196,
		0.00003346765914794806,
		-0.00005635940084759932,
		0.00002613708927959275,
		0.00002533341053138444,
		-0.00005010441151688034,
		0.00002593810263640952,
		0.00002404611936084357,
		-0.00005163238246428602,
		0.00002794638872473000,
		0.00002700739592764804,
		-0.00005939035114511979,
		0.00003210955504312860,
		0.00003438232223525011,
		-0.00007428278434380886,
		0.00003866302665809861,
		0.00004803799918127077,
		-0.00009914141292927652,
		0.00004800025436154043,
		0.00007191960183392704,
		-0.00013922522917537457,
		0.00006043126908005670,
		0.00011338211995240744,
		-0.00020351111316586852,
		0.00007562971718596908,
		0.00018585637209671475,
		-0.00030700846364341576,
		0.00009132512919756623,
		0.00031386108850653502,
		-0.00047464470561729965,
		0.00010030770871287629,
		0.00054232170050706079,
		-0.00074759603610534669,
		0.00008375204845585605,
		0.00095389423083896800,
		-0.00119336225449479362,
		-0.00000327383738614825,
		0.00170107934819055851,
		-0.00192109516273315209,
		-0.00026290310001950487,
		0.00306590657916818192,
		-0.00310372506294090238,
		-0.00091982425407694250,
		0.00556979490215834833,
		-0.00500546835451257978,
		-0.00245869651201214212,
		0.01017705593773498771,
		-0.00800820238034244403,
		-0.00590649361431362999,
		0.01866321477729812259,
		-0.01260156096677063874,
		-0.01341963601206602220,
		0.03429254345271898208,
		-0.01926894593144593687,
		-0.02946277663641767158,
		0.06300065960337521143,
		-0.02800532706641396460,
		-0.06325609033757989552,
		0.11556117355587923468,
		-0.03708367328869965895,
		-0.13352664223772733876,
		0.21104853030721187901,
		-0.03941069742436464907,
		-0.27853504829255953945,
		0.38331715278474703945,
		-0.01491397058539710788,
		-0.57446133459038406510,
		0.68905734940479856920,
		0.09065013779953061401,
		-1.17542205931169707611,
		1.22536662105515059551,
		0.40500835675024698945,
		-2.37977019901803332758,
		2.13411821810153146117,
		1.24184396615612624437,
		-4.78947531960227212977,
		3.64093109251482172084,
		3.27095016057312193425,
		-9.53051815711462246838,
		5.92750355113636295812,
		8.12068845726284394004,
		-18.89123486907114468636,
		9.07245090167984002960,
		18.99435214920948311601,
		-36.62201395750987842348,
		12.69160696640316032813,
		43.73569046442687380249,
		-71.43155879446639744401,
		14.83661067193675719977,
		95.94011857707508283966,
		-135.28537549407113260713,
		4.55415019762845751927,
		212.46383399209483400227,
		-258.45286561264816782568,
		-34.35533596837944259050,
		440.37608695652170354151,
		-466.49328063241102881875,
		-184.78893280632408391284,
		969.10988142292478642048,
		-888.80079051383393107244,
		-485.21897233201576682404,
		1912.15652173913008482486,
		-1381.80553359683767666866,
		-1490.15335968379417863616,
		4216.82213438735107047250,
		-2565.99525691699591334327,
		-3155.47826086956501967506,
		7689.57470355731129529886,
		-3206.47588932806274897303,
		-8547.41501976284416741692,
		17971.70592885375299374573,
		-7203.41501976284507691162,
		-16388.65454545454485923983,
		28589.12885375493715400808,
		-2355.80711462450562976301,
	}
	DER3 = [...]complex128{
		0.37090658903228507226 + 1.33682167078891400713i,
		0.03660096537598455518 + 0.13922215389950498565i,
		-0.16888431840641535131 + 0.09718533619629270148i,
		-0.12681315048680869007 - 0.11831628767028627702i,
		0.04235809310323926380 - 0.10520930088320722129i,
		0.05848306393563178218 - 0.00810224524496080435i,
		0.02340031665294847393 + 0.01807777011820375229i,
		0.00344260984701375092 + 0.01815103755635914459i,
		-0.00803695814441672193 + 0.00917428467034995393i,
		-0.00704695528168774229 - 0.00093958506727472686i,
		-0.00184617963095305509 - 0.00322342583181676459i,
		0.00054064885443097391 - 0.00189672061015605498i,
		0.00102243648088806748 - 0.00055968657179243165i,
		0.00064714396398048754 + 0.00025980661935827123i,
		0.00010444455593372213 + 0.00037199472598828116i,
		-0.00011178535404343476 + 0.00016786687552190863i,
		-0.00010630158710808594 + 0.00002072200033125881i,
		-0.00005078098819110608 - 0.00003575913005741248i,
		-0.00000314742998690270 - 0.00003523185937587781i,
		0.00001347661344130504 - 0.00001333034137448205i,
		0.00000980239082395275 + 0.00000047607184151673i,
		0.00000355493475454698 + 0.00000389816212201278i,
		-0.00000021552652645735 + 0.00000296273413237997i,
		-0.00000131673903627820 + 0.00000097381354534333i,
		-0.00000083401960806066 - 0.00000018663858711081i,
		-0.00000022869610981361 - 0.00000037497716770031i,
		0.00000005372584613379 - 0.00000023060136585176i,
		0.00000011406656653786 - 0.00000006569510293486i,
		0.00000006663595460757 + 0.00000002326630571343i,
		0.00000001396786846375 + 0.00000003315118300198i,
		-0.00000000684890556421 + 0.00000001713041981611i,
		-0.00000000916619598268 + 0.00000000403886083652i,
		-0.00000000502933384276 - 0.00000000222121299478i,
		-0.00000000084484352792 - 0.00000000273668661113i,
		0.00000000070086729861 - 0.00000000124687683156i,
		0.00000000070558101710 - 0.00000000021962577544i,
		0.00000000035900951951 + 0.00000000018774741308i,
		0.00000000005248658571 + 0.00000000021201177126i,
		-0.00000000006264758835 + 0.00000000009059171879i,
		-0.00000000005333473585 + 0.00000000001006078866i,
		-0.00000000002432138144 - 0.00000000001506937008i,
		-0.00000000000331880379 - 0.00000000001544700067i,
		0.00000000000501652570 - 0.00000000000658967459i,
		0.00000000000401214135 - 0.00000000000036708383i,
		0.00000000000158629111 + 0.00000000000119885992i,
		0.00000000000019668766 + 0.00000000000106532662i,
		-0.00000000000036355730 + 0.00000000000047229527i,
		-0.00000000000029920206 + 0.00000000000001251827i,
		-0.00000000000010305550 - 0.00000000000009571381i,
		-0.00000000000000910369 - 0.00000000000007087680i,
		0.00000000000002418310 - 0.00000000000003240337i,
	}
	maclo_d = [...]complex128{
		0.30685281944005469058,
		1.18353470251664338875,
		1.58593285160678321155,
		1.36629265207672068172,
		1.36264601823980036066,
		1.21734246689515424045,
		1.10981816083559525765,
		0.96674692974769849130,
		0.84089872598668435888,
		0.71353210966804747617,
		0.60168548504001373445,
		0.49928574281440518678,
		0.41140086629121763728,
		0.33506195665178500898,
		0.27104779243942234146,
		0.21728554054610033086,
		0.17311050207880035456,
		0.13690016038526570119,
		0.10765949732729711286,
		0.08413804539743192923,
		0.06542450487497340761,
		0.05060001212013485322,
		0.03895655493977817629,
		0.02985084640296329153,
		0.02277908979501017117,
		0.01730960309240666892,
		0.01310389615589767874,
		0.00988251130733762764,
		0.00742735935367278347,
		0.00556296426263720549,
		0.00415334478103463346,
		0.00309116153137843543,
		0.00229387529664008653,
		0.00169729976398295653,
		0.00125245885041635465,
		0.00092172809095368547,
		0.00067661152429638357,
		0.00049544127485341987,
		0.00036192128589181518,
		0.00026376927786672476,
		0.00019180840045267570,
		0.00013917553105723647,
		0.00010077412023867018,
		0.00007281884753121133,
		0.00005251474516228446,
		0.00003779882770351268,
		0.00002715594536867241,
		0.00001947408515177282,
		0.00001394059355016322,
		0.00000996213949015693,
		0.00000710713872292710,
		0.00000506199803708578,
		0.00000359960968975399,
		0.00000255569149787694,
		0.00000181175810338313,
		0.00000128245831538430,
		0.00000090647322737496,
		0.00000063980422418981,
		0.00000045095738191441,
		0.00000031741772125007,
		0.00000022312521183625,
		0.00000015663840476155,
		0.00000010982301013230,
		0.00000007690305934973,
		0.00000005378502675604,
		0.00000003757126131521,
		0.00000002621429405247,
		0.00000001826909956818,
		0.00000001271754463425,
		0.00000000884310192977,
		0.00000000614230041407,
		0.00000000426177146865,
		0.00000000295386817285,
		0.00000000204522503591,
		0.00000000141464900426,
		0.00000000097750884878,
		0.00000000067478454029,
		0.00000000046535930671,
		0.00000000032062550784,
		0.00000000022069891976,
		0.00000000015177557961,
		0.00000000010428189463,
		0.00000000007158597119,
		0.00000000004909806710,
		0.00000000003364531769,
		0.00000000002303635851,
		0.00000000001575933679,
		0.00000000001077213757,
		0.00000000000735717912,
		0.00000000000502077719,
		0.00000000000342362421,
		0.00000000000233271256,
		0.00000000000158818623,
		0.00000000000108046566,
		0.00000000000073450488,
		0.00000000000049894945,
		0.00000000000033868911,
		0.00000000000022973789,
		0.00000000000015572383,
		0.00000000000010548054,
		0.00000000000007139840,
		0.00000000000004829557,
		0.00000000000003264619,
		0.00000000000002205299,
		0.00000000000001488731,
		0.00000000000001004347,
		0.00000000000000677124,
		0.00000000000000456225,
		0.00000000000000307196,
		0.00000000000000206720,
	}
)

func slo(z1 complex128) complex128 {
	var s complex128
	K := 128
	z := (z1 - 1.0) / 2.0
	for k := K - 1; k > 0; k-- {
		s += DEA[k]
		s *= z
	}
	s += DEA[0]
	s += cmplx.Log(z1-Zo)/Zo + cmplx.Log(z1-Zc)/Zc
	return s
}

func ate(z1 complex128) complex128 {
	x := real(z1)
	y := imag(z1)
	if math.Abs(y) > math.Abs(imag(Zo)) {
		return ate(cmplx.Log(z1)) + 1.0
	}
	if x < real(Zo) {
		return ate(cmplx.Exp(z1)) - 1.0
	}
	if x > 2.0 {
		return ate(cmplx.Log(z1)) + 1.0
	}
	z := z1 - 1.0
	LZ := cmplx.Log(z1)
	if cmplx.Abs(LZ-1.0) < cmplx.Abs(z) {
		return ate(LZ) + 1.0
	}
	return slo(z1)
}

func fimai(z complex128) complex128 {
	R := complex128(1.0779614375280 - 0.9465409639480i)
	a2 := 0.5 / (Zo - 1.0)
	a3 := (a2 + 1.0/6.0) / (Zo*Zo - 1.0)
	a4 := (a2/2.0 + a2*a2/2.0 + a3 + 1.0/24.0) / (Zo*Zo*Zo - 1.0)
	a5 := (0.5*a2*a2 + a2/6.0 + a2*a3 + a3/2.0 + a4 + 1.0/120.0) / (Zo*Zo*Zo*Zo - 1.0)
	Li := 2. * math.Pi * 1i
	b0 := 0.1223 - 0.0237i
	e := cmplx.Exp(Zo*z + R)
	c := Zo + e*(1.0+e*(a2+e*(a3+e*(a4+e*a5)))+b0*cmplx.Exp(Li*z))
	return c
}

func tai3i(z complex128) complex128 {
	var s, t complex128
	K := 50
	s = 0.0
	t = 1.0
	z -= 3.0i
	z /= 2.0
	for k := 0; k < K; k++ {
		s += DER3[k] * t
		t *= z
	}
	return s
}

func macloi(z complex128) complex128 {
	var s, z2, t complex128
	K := 100
	z2 = z / 2.0
	t = 1.0
	for k := 0; k <= K; k++ {
		s += maclo_d[k] * t
		t *= z2
	}
	return s + cmplx.Log(z+2.0)
}

func fima(z complex128) complex128 {
	x := real(z)
	y := imag(z)
	if y < 0.2379*x {
		return cmplx.Exp(fima(z - 1.0))
	}
	return fimai(z)
}

func tai3(z complex128) complex128 {
	x := real(z)
	if x > 0.5 {
		return cmplx.Exp(tai3(z - 1.0))
	}
	if x < -0.5 {
		return cmplx.Log(tai3(z + 1.0))
	}
	return tai3i(z)
}

func maclo(z complex128) complex128 {
	x := real(z)
	if x > 0.5 {
		c := z - 1.0
		c = maclo(c)
		c = cmplx.Exp(c)
		return c
	}
	if x < -0.5 {
		return cmplx.Log(maclo(z + 1.0))
	}
	return macloi(z)
}

func tet(z complex128) complex128 {
	y := imag(z)
	if y > 4.5 {
		return fima(z)
	}
	if y > 1.5 {
		return tai3(z)
	}
	if y > -1.5 {
		return maclo(z)
	}
	if y > -4.5 {
		return cmplx.Conj(tai3(cmplx.Conj(z)))
	}
	return cmplx.Conj(fima(cmplx.Conj(z)))
}

func hexp(z, h complex128) complex128 {
	return tet(ate(z) + h)
}

func main() {
	// Define the resolution of the grid
	width := 200
	height := 200
	sw := os.Getenv("WIDTH")
	if sw != "" {
		isw, err := strconv.Atoi(sw)
		if err == nil && isw > 1 {
			width = isw
		}
	}
	sh := os.Getenv("HEIGHT")
	if sh != "" {
		ish, err := strconv.Atoi(sh)
		if err == nil && ish > 1 {
			height = ish
		}
	}

	// Debug
	gDebug = os.Getenv("DEBUG") != ""

	// Define default values for the range of real and imaginary parts
	realMin, realMax := -2.0, 2.0
	imagMin, imagMax := -2.0, 2.0

	// Check if range parameters are provided
	if len(os.Args) >= 5 {
		fmt.Sscanf(os.Args[3], "%f", &realMin)
		fmt.Sscanf(os.Args[4], "%f", &realMax)
	}
	if len(os.Args) >= 6 {
		fmt.Sscanf(os.Args[5], "%f", &imagMin)
		fmt.Sscanf(os.Args[6], "%f", &imagMax)
	}

	// Define a range for the real and imaginary parts of z
	realRange := make([]float64, width)
	for i := range realRange {
		realRange[i] = realMin + (realMax-realMin)*float64(i)/float64(width-1)
	}
	imagRange := make([]float64, height)
	for i := range imagRange {
		imagRange[i] = imagMin + (imagMax-imagMin)*float64(i)/float64(height-1)
	}

	// Create a grid of complex numbers
	grid := make([][]complex128, height)
	for i := range grid {
		grid[i] = make([]complex128, width)
		for j := range grid[i] {
			grid[i][j] = complex(realRange[j], imagRange[i])
		}
	}

	// Define the base of the tetration
	baseReal := 2.0
	baseImag := 0.0 // Default to 0 if not specified

	// Check if both real and imaginary parts are provided
	if len(os.Args) >= 3 {
		fmt.Sscanf(os.Args[1], "%f", &baseReal)
		fmt.Sscanf(os.Args[2], "%f", &baseImag)
	}

	fmt.Printf("(%f,%fi)^^x in (%f,%fi) - (%f,%fi) using %dx%d resolution\n", baseReal, baseImag, realMin, imagMin, realMax, imagMax, width, height)

	// Calculate tetration for each complex number in the grid
	result := make([][]complex128, height)
	for i := range result {
		result[i] = make([]complex128, width)
		for j, z := range grid[i] {
			result[i][j] = Tetration(complex(baseReal, baseImag), z)
		}
	}

	// Generate images for the real and imaginary parts of the result
	saveImage("G.png", result, func(c complex128) float64 { return real(c) })
	saveImage("B.png", result, func(c complex128) float64 { return imag(c) })
	saveImage("R.png", result, func(c complex128) float64 { return cmplx.Abs(c) })
}

// LambertW approximates the Lambert W function using Newton's method.
// It returns the principal branch W(z) for real z >= -1/e and complex z.
func LambertW(z complex128) complex128 {
	const (
		epsilon = 1e-13 // precision
		maxIter = 10000 // maximum iterations
	)

	// Initial guess for Newton's method
	var w complex128
	if real(z) < 0 {
		w = -1
	} else if real(z) == 0 {
		w = 0
	} else {
		w = 1
	}

	// Apply Newton's method
	for i := 0; i < maxIter; i++ {
		wNew := w - (w*cmplx.Exp(w)-z)/(w*(1+w))
		if cmplx.Abs(wNew-w) < epsilon {
			return wNew
		}
		w = wNew
	}

	return w
}

// Tetration computes the tetration of the given base and z
func TetrationGuess(base, z complex128) (fz complex128) {
	if gDebug {
		defer func() {
			fmt.Printf("TetrationGuess(%v, %v) -> %v\n", base, z, fz)
		}()
	}
	fz = cmplx.Pow(base, cmplx.Pow(base, z))
	return
}

// Tetration computes the tetration of the given base and z
func Tetration(base, z complex128) (fz complex128) {
	if gDebug {
		defer func() {
			fmt.Printf("Tetration(%v, %v) -> %v\n", base, z, fz)
		}()
	}
	/////////////
	w := LambertW(cmplx.Log(base))
	result := w
	for n := 2; n <= int(cmplx.Abs(z)); n++ {
		result = w * cmplx.Exp(w*(result-cmplx.Log(w)))
	}
	fz = result
	/////////////
	// This is z-partial iterate of natural exp
	// fz = hexp(base, z)
	// This is natural tetration (base e)
	// fz = tet(z)
	// This is natural arc tetration (base e)
	// fz = ate(z)
	return
}

// saveImage generates an image for the specified part of the result and saves it to a file
func saveImage(filename string, result [][]complex128, partFunc func(complex128) float64) {
	// Normalize the result to [0, 1] for visualization
	min, max := findMinMax(result, partFunc)
	normalized := normalize(min, max, result, partFunc)

	// Generate an image for the part of the result
	img := image.NewGray(image.Rect(0, 0, len(result[0]), len(result)))
	for i := range normalized {
		for j, val := range normalized[i] {
			gray := uint8(val * 255)
			img.SetGray(j, i, color.Gray{gray})
		}
	}

	// Save the image
	file, err := os.Create(filename)
	if err != nil {
		panic(err)
	}
	defer file.Close()
	png.Encode(file, img)
}

// findMinMax finds the minimum and maximum values of the specified part of the result
func findMinMax(result [][]complex128, partFunc func(complex128) float64) (min, max float64) {
	min = partFunc(result[0][0])
	max = partFunc(result[0][0])
	for _, row := range result {
		for _, val := range row {
			part := partFunc(val)
			if part < min {
				min = part
			}
			if part > max {
				max = part
			}
		}
	}
	return min, max
}

// normalize normalizes the values in the result to the range [0, 1]
func normalize(min, max float64, result [][]complex128, partFunc func(complex128) float64) [][]float64 {
	normalized := make([][]float64, len(result))
	for i := range result {
		normalized[i] = make([]float64, len(result[i]))
		for j := range result[i] {
			normalized[i][j] = (partFunc(result[i][j]) - min) / (max - min)
		}
	}
	return normalized
}
